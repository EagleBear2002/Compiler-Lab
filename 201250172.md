# 编译原理 Lab4 实验报告

姓名：熊丘桓

学号：201250127

邮箱：<eaglebear@smail.nju.edu.cn>

## 实现功能

本次实验完成了以下功能：

1. 翻译主函数的定义为中间代码
1. 翻译返回语句为中间代码
1. 计算整形字面常量表达式并翻译为中间代码

## 实验设计

```java
@Override
public LLVMValueRef visitFuncDef(SysYParser.FuncDefContext ctx) {
    LLVMTypeRef functionType = LLVMFunctionType(i32Type, LLVMVoidType(), 0, 0);
    String functionName = ctx.IDENT().getText();
    LLVMValueRef function = LLVMAddFunction(module, functionName, functionType);
    LLVMBasicBlockRef mainEntry = LLVMAppendBasicBlock(function, "mainEntry");
    LLVMPositionBuilderAtEnd(builder, mainEntry);
    super.visitFuncDef(ctx);

    return function;
}
```

笔者按照实验文档设计了 `visitFuncDef` 方法，并根据语法规则设计了 `visitUnaryExp, visitParenExp, visitAddExp, visitMulExp, visitReturnStmt` 等方法。

## 实验困难

笔者初始设计方案是将整形字面常量取值并在 java 中计算表达式求值，但该方案在 OJ 上仅得到了 1300 分（满分 3100）。

```java
private LLVMValueRef binaryOperation(String operator, LLVMValueRef valueRef, LLVMValueRef valueRef2) {
    switch (operator) {
        case "+":
            return LLVMBuildAdd(builder, valueRef, valueRef2, "tmp_");
        case "-":
            return LLVMBuildSub(builder, valueRef, valueRef2, "tmp_");
        case "*":
            return LLVMBuildMul(builder, valueRef, valueRef2, "tmp_");
        case "/":
            return LLVMBuildSDiv(builder, valueRef, valueRef2, "tmp_");
        case "%":
            return LLVMBuildSRem(builder, valueRef, valueRef2, "tmp_");
        default:
            return null;
    }
}
```

